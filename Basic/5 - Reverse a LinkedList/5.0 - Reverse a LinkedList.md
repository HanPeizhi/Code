## [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

反转一个单链表。  

示例:
输入: 1->2->3->4->5->NULL  
输出: 5->4->3->2->1->NULL  

进阶:  
你可以迭代或递归地反转链表。你能否用两种方法解决这道题？

~~~C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        // 迭代法，我感觉准确来说是快慢双指针
        // 当当前指针指向头节点，下一个节点是第二个节点
        // 因为要反转，所以第一个节点也就是头节点就是最后一个节点
        // 比如第二节点要反转的话，第一个节点就是第二节点的上一个节点
        // 同理头节点反转也要指向上一个节点
        // 但是因为是头节点，所以是没有上一个节点的
        // 所以就需要创建一个初始为地址为NULL的指针变量
        // 作为头节点的上一个节点，换句话说就是上一个节点
        
        // 反转的顺序就是
        // 先用next指向当前current的下一个节点：next = cur->next
        // 因为有指针变量指向下一个节点，所以现在不会丢失链表
        // 也就是可以反转当前的节点了，
        // 所以current指向上一个，cur->next = pre
        // 因为是不断循环迭代，所以还要一个cur指针前移右移动的操作
        // 而如果当前指针右移指向下一个节点，
        // 那么当前指针之前还没移动时的节点就是上一个节点
        // 因为我用next保存着下一个节点的地址，
        // 所以虽然当前指针已经指向了上一个节点，但是一样可以下移
        // 但是必须先将pre指向当前cur指向的节点，
        // 不然cur下移以后上一个节点也就是没移动之前的节点的地址就丢失了
        // 所以pre先指向当前cur指针指向的节点：pre = cur
        // 然后cur就可以右一个节点了：cur = next
        // 因为cur一直跟随next的，所以next最后会指向原来链表末端的NULL
        // 所以最后返回的饭一步的pre：return cur
        
        ListNode* pre = NULL;   // slow
        ListNode* next = NULL;  // fast
        ListNode* cur = head;   // cur

        while(cur != NULL){
            next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }

        return pre;
    }
};
~~~

## Reference